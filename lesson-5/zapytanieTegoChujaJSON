#funckja
CREATE OR REPLACE FUNCTION fn_product_attribute_pivot_json()
RETURNS TABLE (
    category_path TEXT,
    product_name TEXT,
    attributes_json JSONB
)
LANGUAGE plpgsql AS
$$
BEGIN
    RETURN QUERY
    WITH RECURSIVE category_path_cte AS (
        SELECT 
            id,
            name,
            parent_id,
            name::TEXT AS path
        FROM "Category"
        WHERE parent_id IS NULL

        UNION ALL

        SELECT 
            c.id,
            c.name,
            c.parent_id,
            cp.path || ' > ' || c.name
        FROM "Category" c
        JOIN category_path_cte cp ON cp.id = c.parent_id
    ),

    product_attr_agg AS (
        SELECT
            pa.product_id,
            a.name AS attribute_name,
            COUNT(vo.option_id) AS value_count
        FROM "ProductAttribute" pa
        JOIN "Attribute" a ON a.id = pa.attribute_id
        JOIN "Option" o ON o.attribute_id = a.id
        JOIN "VariantOption" vo ON vo.option_id = o.id
        GROUP BY pa.product_id, a.name
    )


    product_attrs AS (
        SELECT
            cp.path AS category_path,
            p.name::TEXT AS product_name,
            jsonb_strip_nulls(
                COALESCE(
                    jsonb_object_agg(paa.attribute_name, paa.value_count)
                        FILTER (WHERE paa.attribute_name IS NOT NULL),
                    '{}'::jsonb
                )
            ) AS attributes_json
        FROM "Product" p
        JOIN "ProductCategory" pc ON pc.product_id = p.id
        JOIN category_path_cte cp ON cp.id = pc.category_id
        LEFT JOIN product_attr_agg paa ON paa.product_id = p.id
        GROUP BY cp.path, p.name
    )

    SELECT
        pa.category_path,
        pa.product_name,
        pa.attributes_json
    FROM product_attrs pa
    ORDER BY pa.category_path, pa.product_name;
END;
$$;



#Wywo≈Çanie funkcji
SELECT *
FROM fn_product_attribute_pivot_json();